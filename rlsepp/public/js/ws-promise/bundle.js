(function (MessagePack, EventEmitterModule, globalThis, uuid, util) {
	'use strict';

	function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

	var MessagePack__default = /*#__PURE__*/_interopDefaultLegacy(MessagePack);
	var EventEmitterModule__default = /*#__PURE__*/_interopDefaultLegacy(EventEmitterModule);
	var globalThis__default = /*#__PURE__*/_interopDefaultLegacy(globalThis);
	var uuid__default = /*#__PURE__*/_interopDefaultLegacy(uuid);
	var util__default = /*#__PURE__*/_interopDefaultLegacy(util);

	const{encode,decode}=MessagePack__default['default'];const commonDefaults={encode,decode};var addDefaults = ((options,specifics)=>Object.assign({},commonDefaults,specifics,options));

	const CLOSE_NORMAL=1000;

	function _defineProperty$2(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else {obj[key]=value;}return obj}class Instruction{constructor(command,...args){this.args=args;this.command=command;this.type=this.constructor.type;for(let i=0;i<args.length;++i){const arg=args[i];if(arg instanceof Error){args[i]={error:true,message:arg.message,stack:arg.stack};}}}}class SYN extends Instruction{}_defineProperty$2(SYN,"type",0);class ACK extends Instruction{}_defineProperty$2(ACK,"type",1);class SYN_ACK extends Instruction{}_defineProperty$2(SYN_ACK,"type",2);

	class Message{constructor(instruction,options,id=uuid__default['default']()){this.id=id;this.instruction=instruction;this.options=options;}makeReply(...args){let nextInstruction;const{instruction,options,id}=this;if(instruction instanceof SYN){nextInstruction=ACK;}else if(instruction instanceof ACK){nextInstruction=SYN_ACK;}else {throw new Error("Invalid attempt to reply to a reply")}return new Message(new nextInstruction(instruction.command,...args),options,id)}encode(){return this.options.encode({id:this.id,instruction:this.instruction})}static from(encoded,options){let preprocessed=encoded;if(encoded instanceof ArrayBuffer){preprocessed=new Uint8Array(encoded);}const object=options.decode(preprocessed);const{args,command,type}=object.instruction;const[constructor]=[SYN,ACK,SYN_ACK].filter(c=>c.type===type);const instruction=new constructor(command,...args);return new this(instruction,options,object.id)}}

	var resolve = ((module,key="default")=>{return process.env.NODE_ENV==="test"?module:module[key]||module});

	function _defineProperty$1(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else {obj[key]=value;}return obj}const EventEmitter$1=resolve(EventEmitterModule__default['default']);class Protocol extends EventEmitter$1{constructor(ws,options){super();_defineProperty$1(this,"internal",new EventEmitter$1);this.ws=ws;this.options=options;}read(encoded){const message=Message.from(encoded,this.options);message.client=this;message.reply=(...args)=>{const replyMessage=message.makeReply(...args);return this.send(replyMessage)};const{instruction,id}=message;if(instruction instanceof SYN){const{command,args}=instruction;this.emit(command,message,...args);this.emit("message",command,message,...args);}if(instruction instanceof ACK||instruction instanceof SYN_ACK){this.internal.emit(id,message);}return message}send(message){return new Promise(resolve=>{const{id}=message;this.internal.once(id,reply=>{const{instruction}=reply;const{args}=instruction;resolve([reply,...args]);});this.ws.send(message.encode());})}}

	class RemoteError extends Error{constructor(message,remoteStack){super(message);this.remoteStack=remoteStack;}}

	var proxify = ((around,{encode,decode,bind=false}={})=>new Proxy(around,{get:(target,property,receiver)=>{if(property==="inspect"||property===util__default['default'].inspect.custom){return ()=>{return target}}if(property==="then"){return receiver}const lookUp=target[property];if(!lookUp){return async(...args)=>{const remoteLookUp=new Message(new SYN(property,...args),{encode,decode});const[message,result]=await target.send(remoteLookUp);message.reply();if(result&&result.error&&result.message&&result.stack){throw new RemoteError(result.message,result.stack)}else {return result}}}else {if(bind&&lookUp instanceof Function){return lookUp.bind(target)}else {return lookUp}}}}));

	function _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else {obj[key]=value;}return obj}const EventEmitter=resolve(EventEmitterModule__default['default']);class Client extends EventEmitter{constructor(...args){super({inferListeners:true});_defineProperty(this,"ws",null);_defineProperty(this,"network",null);_defineProperty(this,"reconnecting",false);_defineProperty(this,"options",{});if(!args.length){throw new Error("No arguments provided")}const[url]=args;this.url=url;if(args.length===2){const[,arg2]=args;if(typeof arg2==="object"){this.options=arg2;this.protocols=null;}else {this.protocols=arg2;}}if(args.length===3){const[,protocols,options={}]=args;this.protocols=protocols;this.options=options;}this.options=addDefaults(this.options,{autoReconnect:true,binaryType:"arraybuffer",engine:globalThis__default['default'].WebSocket,reconnectionFactor:1.15,reconnectionMinimum:200});if(!this.options.engine){throw new Error("No WebSocket client implementation found. If your environment doesn't natively support WebSockets, please provide the client class to use with the `engine` option.")}this.proxy=proxify(this,Object.assign({},this.options,{bind:true}));return this.proxy}clear(e){this.emit("close",e);this.network=null;this.ws=null;}open(){return new Promise((resolve,reject)=>{this.close().then(()=>{this.ws=new this.options.engine(this.url,this.protocols,this.options.engineOptions);this.ws.binaryType=this.options.binaryType;this.ws.onopen=e=>{this.emit("open",e);resolve(this.proxy);};this.ws.onerror=e=>{this.emit("error",e);reject(e);};this.ws.onclose=e=>{const{code}=e;this.clear(e);if(code!==CLOSE_NORMAL){if(this.options.autoReconnect&&!this.reconnecting){this.reconnect();}}};this.ws.onmessage=e=>this.network.read(e.data);this.network=new Protocol(this.ws,this.options);this.network.on("*",(...args)=>{this.emit(...args);});}).catch(reject);})}async reconnect(delay){this.reconnecting=true;const timeout=delay||this.options.reconnectionMinimum;try{await this.open();this.reconnecting=false;this.emit("reconnect");}catch(e){setTimeout(()=>{this.reconnect(timeout*this.options.reconnectionFactor);},timeout);}}close(){return new Promise(resolve=>{if(this.ws){this.ws.onclose=e=>{this.clear(e);resolve(this.proxy);};this.ws.close();}else {resolve(this.proxy);}})}async send(message){if(!this.network){throw new Error(`Attempted to send command "${message.instruction.command}" without a connection being established`)}return this.network.send(message)}}

	const client=new Client("ws://portal.grandstreet.group/session");(async()=>{await client.open();const six=await client.add(1,2,3);console.log(six);})();

}(MessagePack, EventEmitterModule, globalThis, uuid, util));
